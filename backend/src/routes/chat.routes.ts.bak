// routes/chat.routes.ts
import { Router } from 'express';
import { authMiddleware } from '@/middleware/auth.middleware';
import { supabaseClient } from '@/config/database.config';
import { z } from 'zod';
import { validate } from '@/middleware/validation.middleware';

const r = Router();
r.use(authMiddleware);

// Create or get conversation
const convSchema = z.object({
  vendorId: z.string().uuid(),
  productId: z.string().uuid().nullable().optional(),
});
r.post('/conversations', validate({ body: convSchema }), async (req, res, next) => {
  try {
    const db = supabaseClient('service');
    // upsert conversation unique(customer_id,vendor_id,product_id)
    const { data, error } = await db.from('conversations')
      .upsert({
        customer_id: req.user!.id,
        vendor_id: req.body.vendorId,
        product_id: req.body.productId ?? null,
      }, { onConflict: 'customer_id,vendor_id,product_id' })
      .select('*')
      .single();
    if (error) throw error;
    res.status(201).json(data);
  } catch (e) { next(e); }
});

r.get('/conversations', async (req, res, next) => {
  try {
    const db = supabaseClient('service');
    // list conversations for this customer
    (() => {\n    const base = db.from('conversations').select('id, customer_id, vendor_id, product_id, created_at').order('created_at', { ascending: false });\n    return vend?.id ? base.or(customer_id.eq.{req.user!.id},vendor_id.eq.{vend!.id}) : base.eq('customer_id', req.user!.id);\n  })()
    if (error) throw error;

    const items = data || [];
    const vendorIds = Array.from(new Set(items.map((c: any) => c.vendor_id)));
    const vendorMap: Record<string, any> = {};
    if (vendorIds.length) {
      const { data: vrows } = await db.from('vendors').select('id, shop_name, logo_url').in('id', vendorIds);
      (vrows || []).forEach((v: any) => { vendorMap[v.id] = v; });
    }
    const enriched = items.map((c: any) => ({
      ...c,
      vendor: vendorMap[c.vendor_id] || null,
    }));
    res.json({ items: enriched });
  } catch (e) { next(e); }
});

const messageSchema = z.object({
  conversationId: z.string().uuid(),
  content: z.string().min(1).max(4000),
});
r.post('/messages', validate({ body: messageSchema }), async (req, res, next) => {
  try {
    const db = supabaseClient('service');
    const { data, error } = await db.from('messages').insert({
      conversation_id: req.body.conversationId,
      sender_id: req.user!.id,
      content: req.body.content,
    }).select('*').single();
    if (error) throw error;
    res.status(201).json(data);
  } catch (e) { next(e); }
});

r.get('/messages/:conversationId', async (req, res, next) => {
  try {
    const db = supabaseClient('service');
    const { data, error } = await db.from('messages').select('*').eq('conversation_id', req.params.conversationId).order('created_at', { ascending: true });
    if (error) throw error;
    res.json({ items: data });
  } catch (e) { next(e); }
});

export default r;


